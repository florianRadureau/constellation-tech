"""
Star detection service using OpenCV.

Detects bright stars/points in constellation images generated by Imagen.
"""

import logging
from dataclasses import dataclass
from typing import Tuple

import cv2
import numpy as np
from PIL import Image

logger = logging.getLogger(__name__)


@dataclass
class StarPosition:
    """
    Position and metadata for a detected star.

    Attributes:
        x: X coordinate in pixels
        y: Y coordinate in pixels
        brightness: Average brightness (0-255)
        color: RGB color tuple
        size: Area in pixels
    """

    x: int
    y: int
    brightness: float
    color: Tuple[int, int, int]
    size: int

    def __repr__(self) -> str:
        """String representation for logging."""
        return (
            f"Star(x={self.x}, y={self.y}, brightness={self.brightness:.1f}, "
            f"size={self.size}, color={self.color})"
        )


class StarDetector:
    """
    Detect star positions in constellation images.
    """

    def __init__(
        self,
        min_brightness: int = 180,
        min_size: int = 10,
        max_stars: int = 20,
    ) -> None:
        """
        Initialize star detector with detection parameters.

        Args:
            min_brightness: Minimum brightness threshold (0-255)
            min_size: Minimum star area in pixels
            max_stars: Maximum number of stars to detect
        """
        self.min_brightness = min_brightness
        self.min_size = min_size
        self.max_stars = max_stars

        logger.info(
            f"StarDetector initialized (brightness≥{min_brightness}, "
            f"size≥{min_size}, max={max_stars})"
        )

    def detect(self, image: Image.Image) -> list[StarPosition]:
        """
        Detect stars in constellation image.

        Algorithm (MVP approach):
        1. Convert to grayscale
        2. Apply brightness threshold
        3. Find contours (connected components)
        4. Filter by size
        5. Calculate center of mass for each blob
        6. Extract dominant color at center
        7. Sort by brightness (descending)

        Args:
            image: PIL Image (RGBA or RGB)

        Returns:
            List of StarPosition objects, sorted by brightness (brightest first)

        Example:
            >>> stars = detector.detect(image)
            >>> brightest = stars[0]  # Brightest star
            >>> print(f"Position: ({brightest.x}, {brightest.y})")
        """
        logger.info(f"Detecting stars in {image.size} image...")

        # Convert PIL to OpenCV format
        cv_image = self._pil_to_cv(image)

        # Convert to grayscale for detection
        gray = cv2.cvtColor(cv_image, cv2.COLOR_BGR2GRAY)

        # Apply brightness threshold
        _, thresh = cv2.threshold(
            gray, self.min_brightness, 255, cv2.THRESH_BINARY
        )

        # Find contours
        contours, _ = cv2.findContours(
            thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
        )

        logger.debug(f"Found {len(contours)} potential stars")

        # Process contours into stars
        stars: list[StarPosition] = []

        for contour in contours:
            # Calculate area
            area = cv2.contourArea(contour)

            if area < self.min_size:
                continue  # Too small

            # Calculate moments for center of mass
            M = cv2.moments(contour)

            if M["m00"] == 0:
                continue  # Invalid contour

            # Center coordinates
            cx = int(M["m10"] / M["m00"])
            cy = int(M["m01"] / M["m00"])

            # Get brightness at center
            brightness = float(gray[cy, cx])

            # Get color at center (from original image)
            color = self._get_color_at_point(cv_image, cx, cy)

            # Create StarPosition
            star = StarPosition(
                x=cx, y=cy, brightness=brightness, color=color, size=int(area)
            )

            stars.append(star)

        # Sort by brightness (descending)
        stars.sort(key=lambda s: s.brightness, reverse=True)

        # Limit to max_stars
        stars = stars[: self.max_stars]

        logger.info(f"Detected {len(stars)} stars (after filtering)")

        # Log top 3 for debugging
        for i, star in enumerate(stars[:3]):
            logger.debug(f"  Star {i+1}: {star}")

        return stars

    def _pil_to_cv(self, image: Image.Image) -> np.ndarray:
        """
        Convert PIL Image to OpenCV format.

        Args:
            image: PIL Image

        Returns:
            OpenCV image (numpy array in BGR format)
        """
        # Convert to RGB if needed
        if image.mode == "RGBA":
            image = image.convert("RGB")
        elif image.mode != "RGB":
            image = image.convert("RGB")

        # Convert to numpy array
        np_image = np.array(image)

        # Convert RGB to BGR (OpenCV format)
        cv_image = cv2.cvtColor(np_image, cv2.COLOR_RGB2BGR)

        return cv_image

    def _get_color_at_point(
        self, cv_image: np.ndarray, x: int, y: int, radius: int = 5
    ) -> Tuple[int, int, int]:
        """
        Get dominant color at a point (with small radius for averaging).

        Args:
            cv_image: OpenCV image (BGR)
            x: X coordinate
            y: Y coordinate
            radius: Radius for color sampling

        Returns:
            RGB color tuple (averaged over radius)
        """
        height, width = cv_image.shape[:2]

        # Ensure coordinates are in bounds
        x = max(0, min(x, width - 1))
        y = max(0, min(y, height - 1))

        # Sample area around point
        x1 = max(0, x - radius)
        x2 = min(width, x + radius + 1)
        y1 = max(0, y - radius)
        y2 = min(height, y + radius + 1)

        region = cv_image[y1:y2, x1:x2]

        # Average color in BGR
        avg_bgr = region.mean(axis=(0, 1))

        # Convert BGR to RGB
        b, g, r = avg_bgr
        return (int(r), int(g), int(b))

    def _estimate_star_size(
        self, gray: np.ndarray, x: int, y: int, radius: int = 25
    ) -> int:
        """
        Estimate star size by counting bright pixels around center.

        Args:
            gray: Grayscale image (numpy array)
            x, y: Star center coordinates
            radius: Search radius in pixels

        Returns:
            Approximate size in pixels (number of bright pixels)
        """
        # Extract region around star
        height, width = gray.shape
        x1 = max(0, x - radius)
        y1 = max(0, y - radius)
        x2 = min(width, x + radius)
        y2 = min(height, y + radius)

        region = gray[y1:y2, x1:x2]

        if region.size == 0:
            return 0

        # Count pixels above 80% of star brightness
        star_brightness = gray[y, x]
        threshold = star_brightness * 0.8
        bright_pixels = int(np.sum(region >= threshold))

        return bright_pixels

    def detect_from_constellation_lines(
        self, image: Image.Image
    ) -> list[StarPosition]:
        """
        DEPRECATED: Line-based detection no longer used.
        Fallback to brightness detection.

        Args:
            image: PIL Image from Imagen

        Returns:
            List of StarPosition objects from brightness detection
        """
        logger.warning(
            "detect_from_constellation_lines is deprecated, using brightness detection"
        )
        return self.detect(image)

    def detect_with_adjustable_threshold(
        self, image: Image.Image, target_count: int
    ) -> list[StarPosition]:
        """
        Detect stars with brightness thresholding and automatic adjustment.

        NOTE: This method is deprecated in the new architecture where
        constellation positions are pre-calculated. Kept as backup/fallback.

        Args:
            image: PIL Image
            target_count: Desired number of stars

        Returns:
            List of StarPosition objects

        Example:
            >>> stars = detector.detect_with_adjustable_threshold(image, target_count=10)
        """
        logger.info(f"Detecting {target_count} stars with brightness thresholding...")

        # Try initial brightness detection
        stars = self.detect(image)

        if len(stars) >= target_count:
            logger.info(f"Found {len(stars)} stars (target: {target_count})")
            return stars[:target_count]

        # Try lowering threshold
        original_brightness = self.min_brightness
        thresholds = [original_brightness - 20, original_brightness - 40]

        for threshold in thresholds:
            if threshold < 100:  # Don't go too low
                break

            logger.debug(f"Trying lower threshold: {threshold}")
            self.min_brightness = threshold
            stars = self.detect(image)

            if len(stars) >= target_count:
                logger.info(
                    f"Found {len(stars)} stars with threshold={threshold}"
                )
                self.min_brightness = original_brightness  # Restore
                return stars[:target_count]

        # Restore original threshold
        self.min_brightness = original_brightness

        logger.warning(
            f"Could only detect {len(stars)} stars (target: {target_count})"
        )
        return stars

    def visualize_detection(
        self, image: Image.Image, stars: list[StarPosition], output_path: str
    ) -> None:
        """
        Visualize detected stars on image (for debugging).

        Args:
            image: Original PIL Image
            stars: List of detected stars
            output_path: Path to save visualization

        Example:
            >>> detector.visualize_detection(image, stars, "debug_stars.png")
        """
        # Convert to OpenCV
        cv_image = self._pil_to_cv(image)

        # Draw circles on each star
        for i, star in enumerate(stars):
            color = (0, 255, 0)  # Green
            cv2.circle(cv_image, (star.x, star.y), 10, color, 2)

            # Add index label
            cv2.putText(
                cv_image,
                str(i + 1),
                (star.x + 15, star.y),
                cv2.FONT_HERSHEY_SIMPLEX,
                0.5,
                color,
                1,
            )

        # Convert back to PIL and save
        cv_rgb = cv2.cvtColor(cv_image, cv2.COLOR_BGR2RGB)
        result_image = Image.fromarray(cv_rgb)
        result_image.save(output_path)

        logger.info(f"Saved visualization to {output_path}")
