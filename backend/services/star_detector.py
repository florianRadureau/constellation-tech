"""
Star detection service using OpenCV.

Detects bright stars/points in constellation images generated by Imagen.
"""

import logging
from dataclasses import dataclass
from typing import Tuple

import cv2
import numpy as np
from PIL import Image

logger = logging.getLogger(__name__)


@dataclass
class StarPosition:
    """
    Position and metadata for a detected star.

    Attributes:
        x: X coordinate in pixels
        y: Y coordinate in pixels
        brightness: Average brightness (0-255)
        color: RGB color tuple
        size: Area in pixels
    """

    x: int
    y: int
    brightness: float
    color: Tuple[int, int, int]
    size: int

    def __repr__(self) -> str:
        """String representation for logging."""
        return (
            f"Star(x={self.x}, y={self.y}, brightness={self.brightness:.1f}, "
            f"size={self.size}, color={self.color})"
        )


class StarDetector:
    """
    Detect star positions in constellation images.

    Uses simple OpenCV threshold method (MVP approach) optimized for
    Imagen-generated constellation images.

    Example:
        >>> detector = StarDetector()
        >>> image = Image.open("constellation.png")
        >>> stars = detector.detect(image)
        >>> print(f"Found {len(stars)} stars")
    """

    def __init__(
        self,
        min_brightness: int = 180,
        min_size: int = 10,
        max_stars: int = 20,
    ) -> None:
        """
        Initialize star detector with detection parameters.

        Args:
            min_brightness: Minimum brightness threshold (0-255)
            min_size: Minimum star area in pixels
            max_stars: Maximum number of stars to detect
        """
        self.min_brightness = min_brightness
        self.min_size = min_size
        self.max_stars = max_stars

        logger.info(
            f"StarDetector initialized (brightness≥{min_brightness}, "
            f"size≥{min_size}, max={max_stars})"
        )

    def detect(self, image: Image.Image) -> list[StarPosition]:
        """
        Detect stars in constellation image.

        Algorithm (MVP approach):
        1. Convert to grayscale
        2. Apply brightness threshold
        3. Find contours (connected components)
        4. Filter by size
        5. Calculate center of mass for each blob
        6. Extract dominant color at center
        7. Sort by brightness (descending)

        Args:
            image: PIL Image (RGBA or RGB)

        Returns:
            List of StarPosition objects, sorted by brightness (brightest first)

        Example:
            >>> stars = detector.detect(image)
            >>> brightest = stars[0]  # Brightest star
            >>> print(f"Position: ({brightest.x}, {brightest.y})")
        """
        logger.info(f"Detecting stars in {image.size} image...")

        # Convert PIL to OpenCV format
        cv_image = self._pil_to_cv(image)

        # Convert to grayscale for detection
        gray = cv2.cvtColor(cv_image, cv2.COLOR_BGR2GRAY)

        # Apply brightness threshold
        _, thresh = cv2.threshold(
            gray, self.min_brightness, 255, cv2.THRESH_BINARY
        )

        # Find contours
        contours, _ = cv2.findContours(
            thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
        )

        logger.debug(f"Found {len(contours)} potential stars")

        # Process contours into stars
        stars: list[StarPosition] = []

        for contour in contours:
            # Calculate area
            area = cv2.contourArea(contour)

            if area < self.min_size:
                continue  # Too small

            # Calculate moments for center of mass
            M = cv2.moments(contour)

            if M["m00"] == 0:
                continue  # Invalid contour

            # Center coordinates
            cx = int(M["m10"] / M["m00"])
            cy = int(M["m01"] / M["m00"])

            # Get brightness at center
            brightness = float(gray[cy, cx])

            # Get color at center (from original image)
            color = self._get_color_at_point(cv_image, cx, cy)

            # Create StarPosition
            star = StarPosition(
                x=cx, y=cy, brightness=brightness, color=color, size=int(area)
            )

            stars.append(star)

        # Sort by brightness (descending)
        stars.sort(key=lambda s: s.brightness, reverse=True)

        # Limit to max_stars
        stars = stars[: self.max_stars]

        logger.info(f"Detected {len(stars)} stars (after filtering)")

        # Log top 3 for debugging
        for i, star in enumerate(stars[:3]):
            logger.debug(f"  Star {i+1}: {star}")

        return stars

    def _pil_to_cv(self, image: Image.Image) -> np.ndarray:
        """
        Convert PIL Image to OpenCV format.

        Args:
            image: PIL Image

        Returns:
            OpenCV image (numpy array in BGR format)
        """
        # Convert to RGB if needed
        if image.mode == "RGBA":
            image = image.convert("RGB")
        elif image.mode != "RGB":
            image = image.convert("RGB")

        # Convert to numpy array
        np_image = np.array(image)

        # Convert RGB to BGR (OpenCV format)
        cv_image = cv2.cvtColor(np_image, cv2.COLOR_RGB2BGR)

        return cv_image

    def _get_color_at_point(
        self, cv_image: np.ndarray, x: int, y: int, radius: int = 5
    ) -> Tuple[int, int, int]:
        """
        Get dominant color at a point (with small radius for averaging).

        Args:
            cv_image: OpenCV image (BGR)
            x: X coordinate
            y: Y coordinate
            radius: Radius for color sampling

        Returns:
            RGB color tuple (averaged over radius)
        """
        height, width = cv_image.shape[:2]

        # Ensure coordinates are in bounds
        x = max(0, min(x, width - 1))
        y = max(0, min(y, height - 1))

        # Sample area around point
        x1 = max(0, x - radius)
        x2 = min(width, x + radius + 1)
        y1 = max(0, y - radius)
        y2 = min(height, y + radius + 1)

        region = cv_image[y1:y2, x1:x2]

        # Average color in BGR
        avg_bgr = region.mean(axis=(0, 1))

        # Convert BGR to RGB
        b, g, r = avg_bgr
        return (int(r), int(g), int(b))

    def detect_with_adjustable_threshold(
        self, image: Image.Image, target_count: int
    ) -> list[StarPosition]:
        """
        Detect stars with automatic threshold adjustment.

        If initial detection doesn't find enough stars, gradually lowers
        the brightness threshold until target_count is reached.

        Args:
            image: PIL Image
            target_count: Desired number of stars

        Returns:
            List of StarPosition objects (may be less than target_count)

        Example:
            >>> stars = detector.detect_with_adjustable_threshold(image, target_count=10)
        """
        logger.info(f"Detecting {target_count} stars with adjustable threshold...")

        # Try initial detection
        stars = self.detect(image)

        if len(stars) >= target_count:
            logger.info(f"Found {len(stars)} stars (target: {target_count})")
            return stars[:target_count]

        # Try lowering threshold
        original_brightness = self.min_brightness
        thresholds = [original_brightness - 20, original_brightness - 40]

        for threshold in thresholds:
            if threshold < 100:  # Don't go too low
                break

            logger.debug(f"Trying lower threshold: {threshold}")
            self.min_brightness = threshold
            stars = self.detect(image)

            if len(stars) >= target_count:
                logger.info(
                    f"Found {len(stars)} stars with threshold={threshold}"
                )
                self.min_brightness = original_brightness  # Restore
                return stars[:target_count]

        # Restore original threshold
        self.min_brightness = original_brightness

        logger.warning(
            f"Could only detect {len(stars)} stars (target: {target_count})"
        )
        return stars

    def visualize_detection(
        self, image: Image.Image, stars: list[StarPosition], output_path: str
    ) -> None:
        """
        Visualize detected stars on image (for debugging).

        Args:
            image: Original PIL Image
            stars: List of detected stars
            output_path: Path to save visualization

        Example:
            >>> detector.visualize_detection(image, stars, "debug_stars.png")
        """
        # Convert to OpenCV
        cv_image = self._pil_to_cv(image)

        # Draw circles on each star
        for i, star in enumerate(stars):
            color = (0, 255, 0)  # Green
            cv2.circle(cv_image, (star.x, star.y), 10, color, 2)

            # Add index label
            cv2.putText(
                cv_image,
                str(i + 1),
                (star.x + 15, star.y),
                cv2.FONT_HERSHEY_SIMPLEX,
                0.5,
                color,
                1,
            )

        # Convert back to PIL and save
        cv_rgb = cv2.cvtColor(cv_image, cv2.COLOR_BGR2RGB)
        result_image = Image.fromarray(cv_rgb)
        result_image.save(output_path)

        logger.info(f"Saved visualization to {output_path}")
