"""
Star detection service using OpenCV.

Detects bright stars/points in constellation images generated by Imagen.
"""

import logging
from dataclasses import dataclass
from typing import Tuple

import cv2
import numpy as np
from PIL import Image

logger = logging.getLogger(__name__)


@dataclass
class StarPosition:
    """
    Position and metadata for a detected star.

    Attributes:
        x: X coordinate in pixels
        y: Y coordinate in pixels
        brightness: Average brightness (0-255)
        color: RGB color tuple
        size: Area in pixels
    """

    x: int
    y: int
    brightness: float
    color: Tuple[int, int, int]
    size: int

    def __repr__(self) -> str:
        """String representation for logging."""
        return (
            f"Star(x={self.x}, y={self.y}, brightness={self.brightness:.1f}, "
            f"size={self.size}, color={self.color})"
        )


class StarDetector:
    """
    Detect star positions in constellation images.

    Uses simple OpenCV threshold method (MVP approach) optimized for
    Imagen-generated constellation images.

    Example:
        >>> detector = StarDetector()
        >>> image = Image.open("constellation.png")
        >>> stars = detector.detect(image)
        >>> print(f"Found {len(stars)} stars")
    """

    def __init__(
        self,
        min_brightness: int = 180,
        min_size: int = 10,
        max_stars: int = 20,
    ) -> None:
        """
        Initialize star detector with detection parameters.

        Args:
            min_brightness: Minimum brightness threshold (0-255)
            min_size: Minimum star area in pixels
            max_stars: Maximum number of stars to detect
        """
        self.min_brightness = min_brightness
        self.min_size = min_size
        self.max_stars = max_stars

        logger.info(
            f"StarDetector initialized (brightness≥{min_brightness}, "
            f"size≥{min_size}, max={max_stars})"
        )

    def detect(self, image: Image.Image) -> list[StarPosition]:
        """
        Detect stars in constellation image.

        Algorithm (MVP approach):
        1. Convert to grayscale
        2. Apply brightness threshold
        3. Find contours (connected components)
        4. Filter by size
        5. Calculate center of mass for each blob
        6. Extract dominant color at center
        7. Sort by brightness (descending)

        Args:
            image: PIL Image (RGBA or RGB)

        Returns:
            List of StarPosition objects, sorted by brightness (brightest first)

        Example:
            >>> stars = detector.detect(image)
            >>> brightest = stars[0]  # Brightest star
            >>> print(f"Position: ({brightest.x}, {brightest.y})")
        """
        logger.info(f"Detecting stars in {image.size} image...")

        # Convert PIL to OpenCV format
        cv_image = self._pil_to_cv(image)

        # Convert to grayscale for detection
        gray = cv2.cvtColor(cv_image, cv2.COLOR_BGR2GRAY)

        # Apply brightness threshold
        _, thresh = cv2.threshold(
            gray, self.min_brightness, 255, cv2.THRESH_BINARY
        )

        # Find contours
        contours, _ = cv2.findContours(
            thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
        )

        logger.debug(f"Found {len(contours)} potential stars")

        # Process contours into stars
        stars: list[StarPosition] = []

        for contour in contours:
            # Calculate area
            area = cv2.contourArea(contour)

            if area < self.min_size:
                continue  # Too small

            # Calculate moments for center of mass
            M = cv2.moments(contour)

            if M["m00"] == 0:
                continue  # Invalid contour

            # Center coordinates
            cx = int(M["m10"] / M["m00"])
            cy = int(M["m01"] / M["m00"])

            # Get brightness at center
            brightness = float(gray[cy, cx])

            # Get color at center (from original image)
            color = self._get_color_at_point(cv_image, cx, cy)

            # Create StarPosition
            star = StarPosition(
                x=cx, y=cy, brightness=brightness, color=color, size=int(area)
            )

            stars.append(star)

        # Sort by brightness (descending)
        stars.sort(key=lambda s: s.brightness, reverse=True)

        # Limit to max_stars
        stars = stars[: self.max_stars]

        logger.info(f"Detected {len(stars)} stars (after filtering)")

        # Log top 3 for debugging
        for i, star in enumerate(stars[:3]):
            logger.debug(f"  Star {i+1}: {star}")

        return stars

    def _pil_to_cv(self, image: Image.Image) -> np.ndarray:
        """
        Convert PIL Image to OpenCV format.

        Args:
            image: PIL Image

        Returns:
            OpenCV image (numpy array in BGR format)
        """
        # Convert to RGB if needed
        if image.mode == "RGBA":
            image = image.convert("RGB")
        elif image.mode != "RGB":
            image = image.convert("RGB")

        # Convert to numpy array
        np_image = np.array(image)

        # Convert RGB to BGR (OpenCV format)
        cv_image = cv2.cvtColor(np_image, cv2.COLOR_RGB2BGR)

        return cv_image

    def _get_color_at_point(
        self, cv_image: np.ndarray, x: int, y: int, radius: int = 5
    ) -> Tuple[int, int, int]:
        """
        Get dominant color at a point (with small radius for averaging).

        Args:
            cv_image: OpenCV image (BGR)
            x: X coordinate
            y: Y coordinate
            radius: Radius for color sampling

        Returns:
            RGB color tuple (averaged over radius)
        """
        height, width = cv_image.shape[:2]

        # Ensure coordinates are in bounds
        x = max(0, min(x, width - 1))
        y = max(0, min(y, height - 1))

        # Sample area around point
        x1 = max(0, x - radius)
        x2 = min(width, x + radius + 1)
        y1 = max(0, y - radius)
        y2 = min(height, y + radius + 1)

        region = cv_image[y1:y2, x1:x2]

        # Average color in BGR
        avg_bgr = region.mean(axis=(0, 1))

        # Convert BGR to RGB
        b, g, r = avg_bgr
        return (int(r), int(g), int(b))

    def _estimate_star_size(
        self, gray: np.ndarray, x: int, y: int, radius: int = 25
    ) -> int:
        """
        Estimate star size by counting bright pixels around center.

        Args:
            gray: Grayscale image (numpy array)
            x, y: Star center coordinates
            radius: Search radius in pixels

        Returns:
            Approximate size in pixels (number of bright pixels)
        """
        # Extract region around star
        height, width = gray.shape
        x1 = max(0, x - radius)
        y1 = max(0, y - radius)
        x2 = min(width, x + radius)
        y2 = min(height, y + radius)

        region = gray[y1:y2, x1:x2]

        if region.size == 0:
            return 0

        # Count pixels above 80% of star brightness
        star_brightness = gray[y, x]
        threshold = star_brightness * 0.8
        bright_pixels = int(np.sum(region >= threshold))

        return bright_pixels

    def detect_from_constellation_lines(
        self, image: Image.Image
    ) -> list[StarPosition]:
        """
        Detect constellation stars by analyzing connection lines.

        Uses Canny edge detection + Hough Line Transform to find thin lines
        connecting stars, then identifies bright stars at line endpoints.

        More robust than brightness thresholding because:
        - Uses Imagen's own constellation structure (the lines it drew)
        - Color-independent (works with any nebula colors)
        - Captures exactly the stars Imagen considers part of constellation

        Algorithm:
        1. Edge detection (Canny) to find thin lines
        2. Hough Line Transform to extract line segments
        3. Find bright stars at line endpoints
        4. Spatial clustering to deduplicate nearby stars
        5. Return constellation stars with full metadata

        Args:
            image: PIL Image from Imagen

        Returns:
            List of StarPosition objects for constellation stars

        Example:
            >>> stars = detector.detect_from_constellation_lines(image)
            >>> print(f"Found {len(stars)} constellation stars")
        """
        import math

        logger.info("Detecting stars via constellation line analysis...")

        # Convert PIL to OpenCV
        cv_image = self._pil_to_cv(image)
        gray = cv2.cvtColor(cv_image, cv2.COLOR_BGR2GRAY)

        # Enhance bright thin lines (reduce noise, keep edges)
        filtered = cv2.bilateralFilter(gray, 9, 75, 75)

        # Canny edge detection to find thin bright lines
        edges = cv2.Canny(filtered, threshold1=50, threshold2=150)

        # Dilate slightly to connect fragmented line segments
        kernel = np.ones((3, 3), np.uint8)
        edges_dilated = cv2.dilate(edges, kernel, iterations=1)

        # Hough Line Transform to detect line segments
        lines = cv2.HoughLinesP(
            edges_dilated,
            rho=1,  # Distance resolution in pixels
            theta=np.pi / 180,  # Angle resolution in radians
            threshold=30,  # Minimum votes
            minLineLength=40,  # Minimum line length in pixels
            maxLineGap=10,  # Maximum gap between segments to treat as one line
        )

        if lines is None or len(lines) == 0:
            logger.warning("No lines detected in image, falling back to brightness detection")
            return self.detect(image)

        logger.debug(f"Found {len(lines)} line segments")

        # Extract all line endpoints
        endpoints = []
        for line in lines:
            x1, y1, x2, y2 = line[0]
            endpoints.append((x1, y1))
            endpoints.append((x2, y2))

        logger.debug(f"Extracted {len(endpoints)} line endpoints")

        # For each endpoint, search for a bright star nearby
        star_candidates = []
        search_radius = 30  # pixels

        for ex, ey in endpoints:
            # Extract region around endpoint
            x1 = max(0, ex - search_radius)
            y1 = max(0, ey - search_radius)
            x2 = min(image.width, ex + search_radius)
            y2 = min(image.height, ey + search_radius)

            region = gray[y1:y2, x1:x2]

            if region.size == 0:
                continue

            # Find brightest point in region
            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(region)

            # Check if bright enough to be a star
            if max_val > 180:  # Bright threshold
                # Convert to absolute coordinates
                star_x = x1 + max_loc[0]
                star_y = y1 + max_loc[1]

                star_candidates.append(
                    {"x": star_x, "y": star_y, "brightness": float(max_val)}
                )

        logger.debug(f"Found {len(star_candidates)} star candidates")

        if len(star_candidates) == 0:
            logger.warning("No bright stars found at line endpoints, falling back")
            return self.detect(image)

        # Spatial clustering to deduplicate stars that are very close
        deduplicated_stars = []
        used = set()

        for i, candidate in enumerate(star_candidates):
            if i in used:
                continue

            # Find all candidates within 30px (same star)
            cluster = [candidate]
            for j, other in enumerate(star_candidates):
                if j <= i or j in used:
                    continue

                distance = math.hypot(
                    candidate["x"] - other["x"], candidate["y"] - other["y"]
                )

                if distance < 30:
                    cluster.append(other)
                    used.add(j)

            # Average position and max brightness for cluster
            avg_x = int(np.mean([s["x"] for s in cluster]))
            avg_y = int(np.mean([s["y"] for s in cluster]))
            max_brightness = max(s["brightness"] for s in cluster)

            deduplicated_stars.append(
                {"x": avg_x, "y": avg_y, "brightness": max_brightness}
            )

        logger.debug(f"After deduplication: {len(deduplicated_stars)} unique stars")

        # Convert to StarPosition objects with full metadata
        stars: list[StarPosition] = []
        for star_data in deduplicated_stars:
            x, y = star_data["x"], star_data["y"]
            brightness = star_data["brightness"]

            # Get color at star position
            color = self._get_color_at_point(cv_image, x, y)

            # Estimate star size
            size = self._estimate_star_size(gray, x, y)

            stars.append(
                StarPosition(
                    x=x, y=y, brightness=brightness, color=color, size=size
                )
            )

        # Sort by brightness (brightest first)
        stars.sort(key=lambda s: s.brightness, reverse=True)

        logger.info(
            f"✓ Detected {len(stars)} constellation stars from line analysis"
        )

        # Log top 3 for debugging
        for i, star in enumerate(stars[:3]):
            logger.debug(f"  Star {i+1}: {star}")

        return stars

    def detect_with_adjustable_threshold(
        self, image: Image.Image, target_count: int
    ) -> list[StarPosition]:
        """
        Detect stars with automatic method selection.

        Primary method: Line-based detection (analyzes constellation lines)
        Fallback method: Brightness thresholding with adjustment

        The line-based method is more robust because it uses the actual
        constellation structure from Imagen (the connection lines), which
        identifies exactly which stars are part of the constellation.

        Args:
            image: PIL Image
            target_count: Desired number of stars

        Returns:
            List of StarPosition objects

        Example:
            >>> stars = detector.detect_with_adjustable_threshold(image, target_count=10)
        """
        logger.info(f"Detecting {target_count} stars...")

        # Try line-based detection first (more robust)
        logger.info("Attempting line-based constellation detection...")
        stars = self.detect_from_constellation_lines(image)

        # If we got a reasonable number of stars, use them
        if len(stars) >= target_count - 2:  # Allow -2 tolerance
            logger.info(
                f"✓ Line-based detection successful: {len(stars)} stars "
                f"(target was {target_count})"
            )
            # Don't limit to target_count - use all detected constellation stars
            return stars

        # Fallback to brightness-based detection
        logger.warning(
            f"Line-based detection found only {len(stars)} stars, "
            f"falling back to brightness detection"
        )

        # Try initial brightness detection
        stars = self.detect(image)

        if len(stars) >= target_count:
            logger.info(f"Found {len(stars)} stars (target: {target_count})")
            return stars[:target_count]

        # Try lowering threshold
        original_brightness = self.min_brightness
        thresholds = [original_brightness - 20, original_brightness - 40]

        for threshold in thresholds:
            if threshold < 100:  # Don't go too low
                break

            logger.debug(f"Trying lower threshold: {threshold}")
            self.min_brightness = threshold
            stars = self.detect(image)

            if len(stars) >= target_count:
                logger.info(
                    f"Found {len(stars)} stars with threshold={threshold}"
                )
                self.min_brightness = original_brightness  # Restore
                return stars[:target_count]

        # Restore original threshold
        self.min_brightness = original_brightness

        logger.warning(
            f"Could only detect {len(stars)} stars (target: {target_count})"
        )
        return stars

    def visualize_detection(
        self, image: Image.Image, stars: list[StarPosition], output_path: str
    ) -> None:
        """
        Visualize detected stars on image (for debugging).

        Args:
            image: Original PIL Image
            stars: List of detected stars
            output_path: Path to save visualization

        Example:
            >>> detector.visualize_detection(image, stars, "debug_stars.png")
        """
        # Convert to OpenCV
        cv_image = self._pil_to_cv(image)

        # Draw circles on each star
        for i, star in enumerate(stars):
            color = (0, 255, 0)  # Green
            cv2.circle(cv_image, (star.x, star.y), 10, color, 2)

            # Add index label
            cv2.putText(
                cv_image,
                str(i + 1),
                (star.x + 15, star.y),
                cv2.FONT_HERSHEY_SIMPLEX,
                0.5,
                color,
                1,
            )

        # Convert back to PIL and save
        cv_rgb = cv2.cvtColor(cv_image, cv2.COLOR_BGR2RGB)
        result_image = Image.fromarray(cv_rgb)
        result_image.save(output_path)

        logger.info(f"Saved visualization to {output_path}")
